<p><b>Диаграмма состояний</b></p>
<p><b>(</b><b>statechart</b> <b>diagram</b><b>)</b></p>
<p>В отличие от других диаграмм, диаграмма состояний описывает процесс изменения состояний системы или ее подсистемы при реализации всех вариантов использования. При этом изменение состояний отдельных элементов системы может быть вызвано внешними воздействиями со стороны других элементов или извне системы. Главное предназначение этой диаграммы описать возможные последовательности состояний и переходов, которые в совокупности характеризуют поведение моделируемой системы в течение всего се жизненного цикла.</p>
<p>Диаграмма состояний представляет динамическое поведение сущностей, на основе спецификации их реакции на восприятие некоторых конкретных событий. Системы, которые реагируют на внешние действия от других систем или от пользователей, иногда называют реактивными. Если такие действия инициируются в произвольные случайные моменты, то говорят об асинхронном поведении модели.</p>
<p>Диаграмма состояний по существу является графом специального вида, который служит для представления некоторого конечного автомата.</p>
<p>Диаграммы состояний могут быть вложены друг в друга, образуя вложенные диаграммы для более детального представления состояний отдельных элементов модели.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><b>8.1. </b></p>
<p><b>Конечные автоматы </b></p>
<p>Конечный автомат (state machine) в языке UML представляет собой некоторый формализм для моделирования поведения отдельных элементов модели или системы в целом. В метамодели UML конечный автомат является пакетом, в котором определено множество понятий, необходимых для представления поведения моделируемой сущности в виде дискретного пространства с конечным числом состояний и переходов. С другой стороны, конечный автомат описывает поведение отдельного объекта в форме последовательности состояний, которые охватывают все этапы его жизненного цикла, начиная от создания объекта и заканчивая его уничтожением.</p>
<p>Каждая диаграмма состояний представляет собой некоторый конечный автомат.</p>
<p>Основными понятиями, входящими в формализм конечного автомата, являются состояние и переход. Основное различие между ними заключается в том, что длительность нахождения системы в отдельном состоянии существенно превышает время, которое затрачивается на переход из одного состояния в другое. Предполагается, что в пределе время перехода из одного состояния в другое равно нулю (если дополнительно ничего не сказано). Другими словами, переход объекта из состояния в состояние происходит мгновенно.</p>
<p>В общем случае конечный автомат представляет динамические аспекты моделируемой системы в виде ориентированного графа, вершины которого соответствуют состояниям, а дуги переходам. При этом поведение моделируется как последовательное перемещение по графу состояний от вершины к вершине, по связывающим их дугам с учетом их ориентации. Для графа состояний системы можно ввести в рассмотрение специальные свойства.</p>
<p>Одним из таких свойств является выделение из всей совокупности двух специальных состояний: начального и конечного. Хотя ни в графе состояний, ни на диаграмме состояний время нахождения системы в том или ином состоянии явно не учитывается, предполагается, что последовательность изменения состояний упорядочена во времени. Другими словами, каждое последующее состояние наступает позже предшествующего ему состояния.</p>
<p>Еще одним свойством графа состояний может служить достижимость состояний. Речь идет о том, что навигация или ориентированный путь в графе состояний определяет специальное бинарное отношение на множестве всех состояний системы. Это отношение характеризует потенциальную возможность перехода системы из рассматриваемого состояния в некоторое другое состояние. Для достижимости состояний необходимо наличие связывающего их ориентированного пути в графе состояний.</p>
<p>Формализм конечных автоматов допускает вложение одних в другие для уточнения внутренней структуры отдельных более общих состояний (макросостояний). В этом случае вложенные конечные автоматы получили название конечных подавтоматов. Подавтоматы могут использоваться для внутренней спецификации процедур и функций, реализация которых обуславливает поведение моделируемой системы или объекта.</p>
<p>В языке UML понятие конечного автомата дополнено специальной семантикой входящих в соответствующий пакет элементов.</p>
<p>Формализм обычного конечного автомата основан на выполнении следующих обязательных условий:</p>
<p>1. Конечный автомат не запоминает историю перемещения из состояния в состояние.</p>
<p>2. В каждый момент конечный автомат может находиться только в одном из своих состояний.</p>
<p>3. Хотя процесс изменения состояний конечного автомата происходит во времени, явно концепция времени не входит в формализм конечного автомата.</p>
<p>4. Количество состояний конечного автомата должно быть обязательно конечным, и все они должны быть специфицированы явным образом.</p>
<p>2.5. Граф конечного автомата не должен содержать изолированных состояний и переходов. Это условие означает, что каждый переход должен обязательно соединять два состояния конечного автомата. Допускается переход из состояния в себя.</p>
<p>3.6. Конечный автомат не должен содержать конфликтующих переходов. В языке UML исключение конфликтов возможно на основе введения так называемых сторожевых условий, которые еще будут рассмотрены.</p>
<p>&nbsp;</p>
<p><b>8.2. </b></p>
<p><b>Состояние </b></p>
<p>В языке UML под состоянием понимается абстрактный мета класс, используемый для моделирования отдельной ситуации, в течение которой имеет место выполнение некоторого условия. Состояние может быть задано в виде набора конкретных значений атрибутов объекта некоторого класса, при этом изменение отдельных значений этих атрибутов будет отражать изменение состояния моделируемого объекта или системы в целом.</p>
<p>Состояние на диаграмме изображается прямоугольником с закругленными вершинами (рис. 8.2). Этот прямоугольник может быть раз делен на две секции горизонтальной линией. Если указана лишь одна секция, то в ней записывается только имя состояния (рис. 8.2, а). В противном случае в первой из них записывается имя состояния, а во второй список некоторых внутренних действий или переходов в данном состоянии (рис. 8.2, 6). При этом под действием в языке UML понимают некоторую атомарную операцию, выполнение которой приводит к изменению состояния или возврату некоторого значения (например, &quot;истина&quot; или &quot;ложь&quot;).</p>
<p><img src="https://sun9-65.userapi.com/impg/ySHO7s6s-i7nFv4R_oT7b2URXMVLtT-ZHRS_UA/fq1nutxALRo.jpg?size=974x346&quality=95&sign=69640870001203c3a6890e5f6a83b57e&type=album"></p>
<p>&nbsp;</p>
<p><b>8.2.1.</b></p>
<p><b>Имя состояния</b></p>
<p>Имя состояния представляет собой строку текста, которая раскрывает содержательный смысл или семантику данного состояния. Имя должно представлять собой законченное предложение и всегда записываться с заглавной буквы. Поскольку состояние системы является составной частью процесса ее функционирования, рекомендуется в качестве имени использовать глаголы в настоящем времени (звенит, печатает, ожидает) или соответствующие причастия (занят, свободен, передано, получено). Как исключение, имя у состояния может отсутствовать. В этом случае состояние является анонимным и если на диаграмме состояний их несколько, то все они должны различаться между собой.</p>
<p>&nbsp;</p>
<p><b>8.2.2. </b></p>
<p><b>Список внутренних действий </b></p>
<p>Для некоторых состояний может потребоваться дополнительно указать некоторые действия, которые должны быть выполнены моделируемым элементом при нахождении его в том или ином состоянии. Для этой цели служит дополнительная секция в обозначении состояния, содержащая перечень внутренних действий или деятельность, которые выполняются в процессе нахождения моделируемого элемента в данном состоянии. Каждое из действий записывается в виде отдельной строки и имеет следующий формат:</p>
<p align="center"><i>&lt;метка действия &lsquo;/`выражение действия&gt;</i></p>
<p>Метка действия указывает на обстоятельства или условия, при которых будет выполняться деятельность, определенная выражением действия. При этом выражение действия может использовать любые атрибуты и связи, которые принадлежат области имен или контексту моделируемого объекта. Если список выражений действия пустой, то метка действия с разделителем в виде наклонной черты &quot;/&quot; &quot; не указываются.</p>
<p>Перечень меток действий в языке UML фиксирован (причем эти метки не могут быть использованы в качестве имен событий):</p>
<ul>
	<li>entry указывает на то, что следующее за ней выражение действия должно быть выполнено в момент входа в данное состояние (входное действие);</li>
	<li>exit указывает на то, что следующее за ней выражение действия должно быть выполнено в момент выхода из данного состояния (выходное действие);</li>
	<li>do специфицирует некоторую деятельность (do activity) или так называемую ду-деятельность, которая выполняется в течение всего времени, пока объект находится в данном состоянии, или до тех пор, пока не будет выполнено условие ее окончания, специфицированное в соответствующей операции класса или вычислительной процедуре. В последнем случае при завершении деятельности генерируется соответствующее событие;</li>
	<li>include используется для обращения к конечному подавтомату, при этом следующее за ней выражение действия содержит имя этого подав томата.</li>
</ul>
<p>Во всех остальных случаях метка действия идентифицирует событие, которое запускает соответствующее выражение действия. Эти события называются внутренними переходами.</p>
<p>&nbsp;</p>
<p><b>8.2.3. </b></p>
<p><b>Начальное состояние </b></p>
<p>Начальное состояние (initial state) представляет собой частный случай состояния, которое не содержит никаких внутренних действий и поэтому относится к категории псевдосостояния. В этом состоянии находится объект по умолчанию в начальный момент. Оно служит для указания на диаграмме состояний графической области, от которой начинается процесс изменения состояний. Графически начальное состояние в языке UML обозначается в виде закрашенного кружка (рис. 8.4, а), из которого может только выходить стрелка-переход.</p>
<p><img src="https://sun9-3.userapi.com/impg/FMwTg2pmzjOtgHLWXKXh7r8uMtkQJtFVquI98A/HP1wo0Vq5Ms.jpg?size=974x291&quality=95&sign=b2d2136b68de79c59e48edbe086c2087&type=album"></p>
<p>На самом верхнем уровне представления объекта переход из начального состояния может быть помечен событием создания (инициализации) данного объекта. В противном случае этот переход никак не помечается. Если этот переход не помечен, то он является первым переходом на диаграмме состояний в следующее за ним состояние. Каждая диаграмма или поддиаграмма состояний должна иметь единственное начальное состояние.</p>
<p>&nbsp;</p>
<p><b>8.2.4. </b></p>
<p><b>Конечное состояние </b></p>
<p>Конечное (финальное) состояние (final state) представляет собой частный случай состояния, которое также не содержит никаких внутренних действий и поэтому также является псевдосостоянием. В этом состоянии должен находиться моделируемый объект или система по умолчанию после завершения работы конечного автомата. Оно служит для указания на диаграмме состояний графической области, в которой завершается процесс изменения состояний или жизненный цикл данного объекта. Графически конечное состояние в языке UML обозначается в виде закрашенного кружка, помещенного в окружность (рис. 8.4, 6), в которую может только входить стрелка переход. Каждая диаграмма состояний или подсостояний может иметь несколько конечных состояний, при этом все они считаются эквивалентными на одном уровне вложенности состояний.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><b>8.3. </b></p>
<p><b>Переход </b></p>
<p><i>Простой переход</i> (simple transition) представляет собой отношение между двумя последовательными состояниями, которое указывает на факт смены одного состояния другим. Пребывание моделируемого объекта или системы в первом состоянии может сопровождаться выполнением некоторых внутренних действий (деятельности), при этом переход в другое состояние будет возможен либо после завершения этих действий (деятельности), либо при возникновении некоторых событий. До срабатывания перехода объект находится в предыдущем от него состоянии, называемом исходным состоянием, или в источнике, а после срабатывания в последующем от него состоянии.</p>
<p>Переход осуществляется при наступлении некоторого события: окончания выполнения деятельности (do activity), получении объектом сообщения или приемом сигнала. На переходе указывается имя события. Кроме того, на переходе могут указываться действия, производимые объектом в ответ на внешние события при переходе из одного состояния в другое. Срабатывание перехода может зависеть не только от наступления некоторого события, но и от выполнения определенного условия, называемого сторожевым условием.</p>
<p>Пример: Объект перейдет из одного состояния в другое в том случае, если произошло указанное событие и сторожевое условие приняло значение &quot;истина&quot;.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><b>8.3.1. </b></p>
<p><b>Событие (event)</b></p>
<p>Событие представляет собой спецификацию некоторого факта, имеющего место в пространстве и во времени. Про события говорят, что они &quot;происходят&quot;, при этом отдельные события должны быть упорядочены во времени. После наступления некоторого события нельзя уже вернуться к предыдущим событиям, если такая возможность не предусмотрена явно в модели.</p>
<p>Семантика понятия события фиксирует внимание на внешних проявлениях качественных изменений, происходящих при переходе моделируемого объекта из состояния в состояние.</p>
<p>В языке UML события играют роль стимулов, которые инициируют переходы из одних состояний в другие. В качестве событий можно рассматривать сигналы, вызовы, окончание фиксированных промежутков времени или моменты окончания выполнения определенных действий. В зависимости от вида происходящих событий стимулов в языке UML различают два типа переходов: триггерные и нетриггерные.</p>
<p>&bull; триггерный переход - это переход, который специфицирует некоторое событие-триггер. В этом случае рядом со стрелкой триггерного перехода обязательно указывается имя события в форме строки текста, начинающейся со строчной буквы. Наиболее часто в качестве имен триггерных переходов задают имена операций, вызываемых у тех или иных объектов системы. После имени такого события следуют круглые скобки для явного задания параметров соответствующей операции. Если таких параметров нет, то список со скобками может отсутствовать.</p>
<p>&bull; нетриггерный переход - это переход, который происходит по завершении выполнения действий (деятельности) в исходном состоянии. Нетриггерные переходы часто называют переходами по завершении ду-деятельности. Для них рядом со стрелкой перехода не указывается никакого имени события, а в исходном состоянии должна быть описана внутренняя дудеятельность, по завершении которой произойдет тот или иной нетриггерный переход.</p>
<p>&nbsp;</p>
<p><b>8.3.2. </b></p>
<p><b>Сторожевое условие </b></p>
<p>Сторожевое условие (guard condition), если оно есть, всегда записывается в прямых скобках и представляет собой некоторое булевское выражение.</p>
<p>Дополнение триггерных и нетриттерных переходов сторожевыми условиями позволяет явно специфицировать семантику их срабатывания. Если сторожевое условие принимает значение &quot;истина&quot;, то соответствующий переход при наступлении события-триггера или завершения деятельности может сработать, в результате чего объект перейдет в целевое состояние. Если сторожевое условие принимает значение &quot;ложь&quot;, то переход не может сработать, даже если произошло событие-триггер или завершилась деятельность в исходном переходе. Очевидно, в случае невыполнения сторожевого условия моделируемый объект или система останется в исходном состоянии. Однако вычисление истинности сторожевого условия в модели происходит только после возникновения ассоциированного с ним события-триггера или завершения деятельности, которые инициируют соответствующий переход.</p>
<p>Поскольку общее количество выходящих из состояния переходов в языке UML никак не ограничено (но конечно), то не исключена ситуация, когда из одного состояния могут выходить несколько переходов с одним и тем же событием-триггером. Каждый из таких переходов должен содержать собственное сторожевое условие, но при этом никакие два или более сторожевых условий не должны одновременно принимать значение &quot;истина&quot;. В противном случае на диаграмме состояний будет иметь место конфликт триггерных переходов, что делает несостоятельной (ill formed) модель системы в целом. &nbsp;Аналогичное замечание справедливо и для нетриггерных переходов.</p>
<p>&nbsp;</p>
<p><b>8.3.3. </b></p>
<p><b>Выражение действия </b></p>
<p>Выражение действия (action expression) выполняется только в том случае, когда переход срабатывает. Представляет собой вызов операции или передачу некоторого сообщения, имеет атомарный характер и выполняется сразу после срабатывания соответствующего перехода до начала каких бы то ни было действий в целевом состоянии. Атомарность действия означает, что оно не может быть прервано никаким другим действием до тех пор, пока не закончится его выполнение. Данное действие может оказывать влияние как на сам объект, так и на его окружение, если это с очевидностью следует из контекста модели. Данное выражение записывается после знака &quot;/&quot; в строке текста, присоединенной к соответствующему переходу.</p>
<p>В общем случае, выражение действия может содержать целый список от дельных действий, разделенных символом &quot;;&quot;. Обязательное требование все действия из списка должны четко различаться между собой и следовать в порядке их записи. На синтаксис записи выражений действия не накладывается никаких ограничений. Главное их запись должна быть понятна разработчикам модели и программистам. Поэтому чаще всего выражения записывают на одном из языков программирования, который предполагается использовать для реализации модели.</p>
<p>&nbsp;</p>
<p><b>8.4. </b></p>
<p><b>Составное состояние и подсостояние</b></p>
<p>Составное состояние (composite state) - сложное состояние, которое состоит из других вложенных в него состояний. Последние выступают по отношению к первому как подсостояния (substate). Хотя между ними имеет место отношение композиции, графически все вершины диаграммы, которые соответствуют вложенным состояниям, изображаются внутри символа составного состояния (рис. 8.6). В этом случае размеры графического символа составного состояния увеличиваются так, чтобы вместить в себя все подсостояния.</p>
<p><img src="https://sun9-53.userapi.com/impg/ycQIy-FfrXA2LKTYSgayiHzFb98tHnFBirQwZA/tebm7VF2S8A.jpg?size=974x416&quality=95&sign=17fd659cd0b4db29476c559d3b113348&type=album"></p>
<p>Составное состояние, которое называют также <i>суперсостоянием</i> или <i>состоянием-композитом</i>, может содержать или несколько последовательных подсостояний, или несколько параллельных конечных подавтоматов. Каждое суперсостояние может уточняться только одним из указанных способов. При этом любое из подсостояний, в свою очередь, может являться составным состоянием и содержать внутри себя другие вложенные подсостояния. Количество уровней вложенности составных состояний в языке UML не фиксировано.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><b>8.4.1. </b></p>
<p><b>Последовательные подсостояния </b></p>
<p>Последовательные подсостояния (sequential substates) используются для моделирования такого поведения объекта, во время которого в каждый момент объект может находиться в одном и только одном подсостоянии. Поведение объекта в этом случае представляет собой последовательную смену подсостояний, начиная от начального и заканчивая конечным подсостоянием. Хотя моделируемый объект или система продолжает находиться в составном состоянии, введение в рассмотрение последовательных подсостояний позволяет учесть более тонкие логические аспекты его внутреннего поведения.</p>
<p>Каждое составное состояние должно содержать в качестве вложенных подсостояний начальное и конечное. При этом начальное подсостояние является исходным, когда происходит переход объекта в данное составное состояние. Если составное состояние содержит внутри себя конечное (финальное) подсостояние, то переход в это вложенное конечное состояние означает завершение нахождения объекта в данном суперсостоянии. Важно помнить, что для последовательных подсостояний начальное и конечное состояния должны быть единственными в каждом составном состоянии.</p>
<p>&nbsp;</p>
<p><b>8.4.2. </b></p>
<p><b>Параллельные подсостояния </b></p>
<p>Параллельные подсостояния (concurrent substates) позволяют специфицировать два и более конечных подавтомата, которые могут выполняться параллельно внутри составного события. Каждый из конечных подавтоматов занимает некоторую область (регион) внутри составного состояния, которая отделяется от остальных горизонтальной пунктирной линией. Если на диаграмме состояний имеется составное состояние с вложенными параллельными подсостояниями, то объект может одновременно находиться в каждом из этих подсостояний.</p>
<p>Отдельные параллельные подсостояния могут, в свою очередь, состоять из нескольких последовательных подсостояний (конечные подавтоматы 1 и 2 на рис. 8.8). В этом случае по определению объект может находиться только в одном из последовательных подсостояний конечного полавтомата. Таким образом, для абстрактного примера (рис. 8.8) допустимо одновременное нахождение объекта в подсостояниях (1, 3, 4), (2, 3, 4), (1, 3, 5), (2, 3, 5). Недопустимо нахождение объекта одновременно в подсостояниях (1,2,3) или (3, 4, 5).</p>
<p><img src="https://sun9-79.userapi.com/impg/c7tr0LRihkpGA_sDg7PlHkcaXC_lIGAbEqlc5A/ofdVHm5_6KA.jpg?size=974x502&quality=95&sign=9074b32e4e6b963bcf8208bd4e1810bc&type=album"></p>
<p>&nbsp;</p>
<p><b>8.5. </b></p>
<p><b>Исторические состояния</b></p>
<p>Историческое состояние (history state) применяется только в контексте составного состояния. Оно используется для запоминания того из последовательных подсостояний, которое было текущим в момент выхода из составного состояния. При этом существует две разновидности исторического состояния: неглубокое (недавнее) и глубокое (давнее) (рис. 8.10).</p>
<p><img src="https://sun9-52.userapi.com/impg/nt_4P5W1893EfCIB_M3YPdXX1llLUWm6mwcDdQ/moxMcQaIABQ.jpg?size=755x205&amp;quality=95&amp;sign=ba6741ff86f6f4018f4762640da6f762&amp;type=album"></p>
<p><i>Неглубокое историческое состояние</i> (shallow history state) обозначается в форме небольшой окружности, в которую помещена латинская буква &quot;Н&quot; (рис. 8.10, а). Это состояние обладает следующей семантикой. Во-первых, оно является первым подсостоянием в составном состоянии, и переход извне в рассматриваемое составное состояние должен вести непосредственно в данное историческое состояние. Во-вторых, при первом попадании в неглубокое историческое состояние оно не хранит никакой истории (история пуста).</p>
<p>Далее может следовать последовательное изменение вложенных подсостояний. Если в некоторый момент происходит выход из составного состояния (например, в случае наступления некоторого события), то рассматриваемое историческое состояние запоминает (сохраняет) то из подсостояний, которое являлось текущим на момент выхода из данного составного состояния. При последующем входе в это составное состояние неглубокое историческое подсостояние имеет непустую историю и сразу отправляет конечный подавтомат в сохраненное подсостояние, минуя все предшествующие ему подсостояния.</p>
<p>Историческое состояние теряет свою историю в тот момент, когда конечный подавтомат доходит до своего конечного состояния. При этом неглубокое историческое состояние запоминает историю только того конечного подавтомата, к которому оно относится.</p>
<p>Если сохраненное подсостояние также является составным состоянием, а при выходе из исходного составного состояния необходимо запомнить некоторое подсостояние второго уровня вложенности, то в этом случае следует воспользоваться более сильным псевдосостоянием глубоким историческим состоянием.</p>
<p><i>Глубокое историческое состояние</i> (deep history state) также обозначается в форме небольшой окружности, в которую помещена латинская буква &quot;Н&quot; с дополнительным символом &quot;*&quot; (звездочка) (рис. 8.10, б), и служит для запоминания всех подсостояний любого уровня вложенности для исходного составного состояния.</p>



<style> 
	body 
	{ 
		margin-right: 370px;
		margin-left: 370px;
	}

    img {
      display: block;
      margin-left: auto;
      margin-right: auto;
    }

</style>